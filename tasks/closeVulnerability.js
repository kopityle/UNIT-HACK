import { playSound } from '../utils/audio.js';

export function setupCloseVulnerabilityTask({ gameAreaElement, taskTitleElement, completeTask, gameState, updateScore, playSound: playSoundFromGame }) {
    taskTitleElement.textContent = 'Закрой все уязвимости в системе';

    // Создание иконки сервера (центрируется через CSS flex в gameArea)
    const serverContainer = document.createElement('div');
    serverContainer.className = 'server-icon';

    const serverImg = document.createElement('img');
    serverImg.src = 'assets/img/server-icon.png';
    serverImg.alt = 'Server Icon';
    serverContainer.appendChild(serverImg);

    gameAreaElement.appendChild(serverContainer);

    // Создание 3-5 уязвимостей
    const numVulnerabilities = Math.floor(Math.random() * 3) + 3; // 3-5 уязвимостей
    let vulnerabilitiesClosed = 0;
    const vulnerabilityElements = []; // Отслеживание элементов уязвимостей

    // Позиционирование уязвимостей относительно serverContainer
    const serverRect = serverContainer.getBoundingClientRect();
    const gameRect = gameAreaElement.getBoundingClientRect(); // Предполагаем, что gameArea позиционирован

    // Размер уязвимости
    const vulSize = 30;
    const padding = 15;

    // Calculate server position relative to gameArea
    const serverRelativeX = serverRect.left - gameRect.left;
    const serverRelativeY = serverRect.top - gameRect.top;

    // Generate and place vulnerabilities
    for (let i = 0; i < numVulnerabilities; i++) {
        // Use a delay for spawning effect
        setTimeout(() => {
             if (!gameState.isPlaying || vulnerabilitiesClosed >= numVulnerabilities) return; // Stop spawning if game ends or task is completed

            // Create vulnerability
            const vulnerability = document.createElement('div');
            vulnerability.className = 'vulnerability';

            // Position randomly within server bounds, with padding
            let randX, randY;
            let collision = true;
            let attempts = 0;
            const maxAttempts = 50; // Prevent infinite loop

            // Try to find a position that doesn't overlap significantly with others
            while(collision && attempts < maxAttempts) {
                 randX = serverRelativeX + padding + Math.random() * (serverRect.width - vulSize - 2 * padding);
                 randY = serverRelativeY + padding + Math.random() * (serverRect.height - vulSize - 2 * padding);

                 collision = vulnerabilityElements.some(existingVul => {
                     const dist = Math.sqrt(
                         Math.pow(randX - parseFloat(existingVul.style.left), 2) +
                         Math.pow(randY - parseFloat(existingVul.style.top), 2)
                     );
                     return dist < vulSize; // Check if centers are too close
                 });
                 attempts++;
            }

            vulnerability.style.left = `${randX}px`;
            vulnerability.style.top = `${randY}px`;

            gameAreaElement.appendChild(vulnerability);
            vulnerabilityElements.push(vulnerability); // Add to tracking list

            // Add click handler
            vulnerability.addEventListener('click', function handler() {
                // Remove the event listener after first click
                this.removeEventListener('click', handler);

                vulnerabilitiesClosed++; // Increment count

                this.style.backgroundColor = 'var(--success-color)';
                this.style.animation = 'none'; // Stop pulsing animation
                 this.style.cursor = 'default'; // Change cursor
                 playSoundFromGame('click');


                if (vulnerabilitiesClosed >= numVulnerabilities) {
                    // Disable clicks on all remaining vulnerabilities (if any were spawned late)
                    vulnerabilityElements.forEach(vul => {
                         const clone = vul.cloneNode(true);
                         vul.parentNode.replaceChild(clone, vul);
                    });

                    completeTask(true, Math.floor(gameState.timeLeft / 10));
                }
            });
        }, i * 200); // Spawn with a slight delay
    }
}